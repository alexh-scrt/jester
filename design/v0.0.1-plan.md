# Jester v0.0.1 Implementation Plan

> Goal: ship the **“Court Entrance”** pre-release (v0.0.1) with a single-node TLS → HTTP reverse proxy, typed configuration, tracing logs, and the scaffolding for future plugin work.

## Scope & Exit Criteria
- Accept inbound TLS (rustls) and proxy HTTP/1.1 + h2 requests to a single upstream target.
- Route selection via host + path-prefix matchers.
- Config lives in TOML, validated on start (`jester config validate`).
- Structured logs with `tracing`, plus basic metrics hooks (counter placeholders).
- CLI (`jester run`) starts the proxy; `jester config example` outputs sample config.
- Unit + smoke tests cover config parsing/validation and a happy-path proxy loop.

Anything outside this list (WASM, advanced load balancing, admin API, hot reload) is deferred to later milestones.

## Workstreams & Tasks

### 1. Runtime Foundations
1. Implement listener bootstrap:
   - rustls-based TLS acceptor (cert/key from config).
   - ALPN negotiation for HTTP/1.1 + HTTP/2 (Hyper server).
2. Router + service graph:
   - Define router trait and match host/path-prefix.
   - Build Tower stack: router layer → proxy handler → Hyper client to upstream.
3. Upstream client:
   - Hyper client with connection pooling.
   - Basic timeout + error translation.
4. Graceful shutdown:
   - Ctrl+C signal handler, connection draining timer.

### 2. Configuration & CLI
1. Expand `Config::validate` with:
   - Schema-like checks (unique listener names, valid bind syntax, non-empty upstream URLs).
   - Friendly error messages.
2. Add `jester config lint` stub (returns “not implemented” but reserves UX).
3. Support env interpolation `${VAR:DEFAULT}` at load time.
4. Document config schema in `examples/config/README.md` + update `README.md`.

### 3. Plugin & Extensibility Scaffolding
1. Define `JesterPlugin` registry interface and wire Tier A (in-proc) placeholder filters:
   - Built-in timeout/filter stubs implementing the trait.
2. Add plugin discovery stub:
   - Scan configured paths, report found manifests (even if not loading yet).
3. Provide `jester new plugin --wasm` TODO entry in CLI help pointing to future work.

### 4. Observability & Ops
1. Logging:
   - Structured request/response span with IDs.
   - User-facing log levels controlled via CLI flag (`--log-level`).
2. Metrics:
   - Expose `metrics` crate counters (requests_total, errors_total) with a simple stdout exporter for now.
3. Diagnostics:
   - Implement `jester tap --route <name>` placeholder that tails tracing spans (printing filtered logs).
   - Add `jester diag` stub that prints the resolved config.

### 5. Testing, Tooling & Release
1. Unit tests:
   - Config parsing/validation edge cases.
   - Router matcher tests.
   - Plugin registry smoke test.
2. Integration test:
   - Spin up Hyper server + run proxy to ensure end-to-end flow (use `tokio::test` + loopback).
3. Automation:
   - GitHub Actions (fmt, clippy, check, test) with caching.
4. Versioning:
   - Tag `v0.0.1` after successful CI.
   - Release notes summarizing scope.

## Timeline (high-level)
- **Week 1**: Runtime foundations + config validation.
- **Week 2**: CLI polish, plugin scaffolding, observability hooks.
- **Week 3**: Testing, docs, CI, release packaging.

## Dependencies & Risks
- **Crate downloads**: Offline dev needs vendored crates or `cargo vendor`.
- **TLS cert management**: For v0.0.1 rely on user-provided certs; ACME later.
- **HTTP/2**: Ensure ALPN handshake fallback to h1 when h2 unsupported.
- **Resource limits**: Add TODOs where hardening (timeouts, body size) is required but not yet implemented.

## Deliverables Checklist
- [ ] TLS listener + proxy path working.
- [ ] Config validation errors tested.
- [ ] CLI commands (`run`, `config validate/example`, `plugins list`) functional.
- [ ] Plugin registry + built-in timeout filter stub.
- [ ] Tracing logs + metrics counters.
- [ ] Documentation updated (`README`, `examples`, design docs referencing v0.0.1).
- [ ] CI workflow + tag `v0.0.1`.
